# Description: This script is used to control the minidrone in the UAM environment.

from omni.kit.scripting import BehaviorScript
import carb
from pxr import Sdf
from omni.isaac.core.prims import RigidPrimView
from pxr import Usd, UsdGeom, Gf

import numpy as np
import math
from scipy.spatial.transform import Rotation



class UAM_minidrone(BehaviorScript):


    def on_init(self):
        print(f"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n")
        print(f"INIT  {self.prim_path}")

        ########################################################################
        ## Omniverse

        self.pos_atr    = self.prim.GetAttribute("xformOp:translate")
        self.ori_atr    = self.prim.GetAttribute("xformOp:orient")

        self.linVel_atr = self.prim.GetAttribute("physics:velocity")
        self.angVel_atr = self.prim.GetAttribute("physics:angularVelocity")

        self.force_atr = self.prim.GetAttribute("physxForce:force")
        self.force_atr.Set(Gf.Vec3f(0,0,0))
        self.torque_atr = self.prim.GetAttribute("physxForce:torque")
        self.torque_atr.Set(Gf.Vec3f(0,0,0))

        primNE = self.prim.GetChild("rotor_NE")
        self.forceNE_atr = primNE.CreateAttribute("physxForce:force", Sdf.ValueTypeNames.Float3)
        self.forceNE_atr.Set(Gf.Vec3f(0,0,0))

        primNW = self.prim.GetChild("rotor_NW")
        self.forceNW_atr = primNW.CreateAttribute("physxForce:force", Sdf.ValueTypeNames.Float3)
        self.forceNW_atr.Set(Gf.Vec3f(0,0,0))

        primSE = self.prim.GetChild("rotor_SE")
        self.forceSE_atr = primSE.CreateAttribute("physxForce:force", Sdf.ValueTypeNames.Float3)
        self.forceSE_atr.Set(Gf.Vec3f(0,0,0))

        primSW = self.prim.GetChild("rotor_SW")
        self.forceSW_atr = primSW.CreateAttribute("physxForce:force", Sdf.ValueTypeNames.Float3)
        self.forceSW_atr.Set(Gf.Vec3f(0,0,0))        
        

        ########################################################################
        ## Navigation parameters

        # rotor engine status on/off
        self.rotors_on = False

        # AutoPilot navigation command
        cmd_on = False          # (bool) motores activos 
        cmd_velX = 0.0          # (m/s)  velocidad lineal  deseada en eje X
        cmd_velY = 0.0          # (m/s)  velocidad lineal  deseada en eje Y
        cmd_velZ = 0.0          # (m/s)  velocidad lineal  deseada en eje Z
        cmd_rotZ = 0.0          # (m/s)  velocidad angular deseada en eje Z
        CommandExpTime = None   # (s)    tiempo de expiracion del comando


        ########################################################################
        ## quadcopter parameters

        self.g    = 9.8

        mass_attr = self.prim.GetAttribute("physics:mass")
        self.mass = mass_attr.Get()
        # print(f"mass: {self.mass}")

        inertia_attr = self.prim.GetAttribute("physics:diagonalInertia")
        self.inertia = inertia_attr.Get()
        # print(f"inertia: {self.inertia}")

        self.pos   = Gf.Vec3f(0, 0, 0)
        self.roll  = 0
        self.pitch = 0
        self.yaw   = 0
        self.linear_vel  = Gf.Vec3f(0, 0, 0)
        self.angular_vel = Gf.Vec3f(0, 0, 0)

        # Rotor speed (rad/s)
        # asumimos velocidad máxima de 6000rpm = 628.3185 rad/s
        self.w_rotor_NE = 0.0
        self.w_rotor_NW = 0.0
        self.w_rotor_SE = 0.0
        self.w_rotor_SW = 0.0
    
        # Aerodynamic thrust force constant
        # Force generated by the rotors is FT = kFT * w²
        self.kFT = 1.7179e-05                                    # assuming that FT_max = 0.692kg
        self.w_hov = (self.mass * self.g / 4 / self.kFT) ** 0.5  # 291.45 rad/s

        # Aerodynamic drag force constant
        # Moment generated by the rotors is MDR = kMDR * w²
        self.kMDR = 3.6714e-08

        # Aerodynamic drag force constant per axis
        # Drag force generated by the air friction, opposite to the velocity is FD = -kFD * r_dot*|r_dot| (depends on the shape of the object in each axis).
        # Horizontal axis:
        self.kFDx = 1.1902e-04
        self.kFDy = 1.1902e-04
        # Vertical axis:
        self.kFDz = 36.4437e-4

        # Aerodynamic drag moment constant per axis
        # Drag moment generated by the air friction, opposite to the angular velocity is MD = -kMD * rpy_dot*|rpy_dot| (depends on the shape of the object in each axis).

        # Horizontal axis:
        # Assuming similar drag in both axes (although the fuselage is not equal), no gravity and the drone is propulsed by two rotors of the same side at maximum speed the maximum angular velocity is Vrp_max = 2 * 2*pi;
        # operating kMDxy =  2 * FT_max * sin(deg2rad(45))^2 / Vrp_max^2 we get that...
        self.kMDx = 1.1078e-04
        self.kMDy = 1.1078e-04

        # Vertical axis:
        # Must be verified at maximum yaw velocity
        # Assuming that Vyaw_max = 4*pi rad/s (max yaw velocity of 2rev/s) and w_hov2 (rotor speed to maintain the hovering)
        # And taking into account that MDR = kMDR * w² and MDz = kMDz * Vyaw²
        # operating MDz  = MDR (the air friction compensates the effect of the rotors) and kMDz = kMDR* (2 * w_hov2²) / Vyaw_max² we get that...
        self.kMDz = 7.8914e-05



        ########################################################################

 



    def on_play(self):
        print(f"PLAY  {self.prim_path}")
        self.force_atr.Set(Gf.Vec3f(0,0,0))
        self.torque_atr.Set(Gf.Vec3f(0,0,0))
        self.forceNE_atr.Set(Gf.Vec3f(0,0,0))
        self.forceNW_atr.Set(Gf.Vec3f(0,0,0))
        self.forceSE_atr.Set(Gf.Vec3f(0,0,0))
        self.forceSW_atr.Set(Gf.Vec3f(0,0,0))        
        pass

 



    def on_stop(self):
        print(f"STOP  {self.prim_path}")

  






    def on_update(self, current_time: float, delta_time: float):
        # print(f"UPDATE  {self.prim_path} \t {current_time} \t {delta_time}")

        self.IMU()
        self.platform_dynamics()
        pass




    def IMU(self):

        self.pos  = self.pos_atr.Get()
        # print(f"\nposition:  {self.pos}")

        self.ori  = self.ori_atr.Get()
        # print(f"\norientation:  {self.ori}")
     
        W = self.ori.real
        X = self.ori.imaginary[0]
        Y = self.ori.imaginary[1]
        Z = self.ori.imaginary[2]
        # print(f"Orientation:  {W:.4f} {X:.4f} {Y:.4f} {Z:.4f}")

        # r,p,y = self.quat2euler(W,X,Y,Z)
        # print(f"Euler1:  {r} {p} {y}")
        rot = Rotation.from_quat([X,Y,Z,W])     
        self.roll, self.pitch, self.yaw = rot.as_euler('xyz', degrees=True)
        # print(f"Euler RPY:  {self.roll:.0f} {self.pitch:.0f} {self.yaw:.0f}")

        self.linear_vel  = self.linVel_atr.Get()
        # print(f"linear velocity  (local):  {self.linear_vel}")

        self.angular_vel = self.angVel_atr.Get() * np.pi / 180
        # print(f"angular velocity (local):  {self.angular_vel}")


    # def quat2euler(self, w, x, y, z):

    #     t0 = +2.0 * (w * x + y * z)
    #     t1 = +1.0 - 2.0 * (x * x + y * y)
    #     roll_x = math.degrees(math.atan2(t0, t1))

    #     t2 = +2.0 * (w * y - z * x)
    #     t2 = +1.0 if t2 > +1.0 else t2
    #     t2 = -1.0 if t2 < -1.0 else t2
    #     pitch_y = math.degrees(math.asin(t2))

    #     t3 = +2.0 * (w * z + x * y)
    #     t4 = +1.0 - 2.0 * (y * y + z * z)
    #     yaw_z = math.degrees(math.atan2(t3, t4))

    #     return roll_x, pitch_y, yaw_z
        



    def platform_dynamics(self):
        # Esta función traduce 
        # la velocidad de rotación de los 4 motores
        # a fuerzas y torques del sólido libre
        
        # Con esto simulamos rotación de sustentación
        self.w_rotor_NE = self.w_hov
        self.w_rotor_NW = self.w_rotor_NE
        self.w_rotor_SE = self.w_rotor_NE
        self.w_rotor_SW = self.w_rotor_NE

        # # Con esto simulamos rotación de giro
        # self.w_rotor_NE = (self.mass * self.g / 2 / self.kFT) ** 0.5
        # self.w_rotor_NW = 0
        # self.w_rotor_SE = 0
        # self.w_rotor_SW = self.w_rotor_NE

        # Apply thrust force
        FT_NE = Gf.Vec3f(0, 0, self.kFT * self.w_rotor_NE**2)
        FT_NW = Gf.Vec3f(0, 0, self.kFT * self.w_rotor_NW**2)
        FT_SE = Gf.Vec3f(0, 0, self.kFT * self.w_rotor_SE**2)
        FT_SW = Gf.Vec3f(0, 0, self.kFT * self.w_rotor_SW**2)
        self.forceNE_atr.Set(FT_NE)
        self.forceNW_atr.Set(FT_NW)
        self.forceSE_atr.Set(FT_SE)
        self.forceSW_atr.Set(FT_SW)


        # Apply the air friction force to the drone
        FD = Gf.Vec3f(
            -self.kFDx * self.linear_vel[0] * abs(self.linear_vel[0]),
            -self.kFDy * self.linear_vel[1] * abs(self.linear_vel[1]),
            -self.kFDz * self.linear_vel[2] * abs(self.linear_vel[2]))
        self.force_atr.Set(FD)
      
      
        # Compute the drag moment
        MDR_NE = self.kMDR * self.w_rotor_NE**2
        MDR_NW = self.kMDR * self.w_rotor_NW**2
        MDR_SE = self.kMDR * self.w_rotor_SE**2
        MDR_SW = self.kMDR * self.w_rotor_SW**2
        MDR = Gf.Vec3f(0, 0, MDR_NE - MDR_NW - MDR_SE + MDR_SW)
        # print(f"MDR  = {MDR}")

        # Compute the air friction moment
        MD = Gf.Vec3f(
            -self.kMDx * self.angular_vel[0] * abs(self.angular_vel[0]),
            -self.kMDy * self.angular_vel[1] * abs(self.angular_vel[1]),
            -self.kMDz * self.angular_vel[2] * abs(self.angular_vel[2]))
        # print(f"MD  = {MD}")

        # Apply the moments to the drone
        self.torque_atr.Set(MDR + MD)
        # print(f"Torque  = {MDR[2] + MD[2]}")
